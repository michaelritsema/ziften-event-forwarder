// Code generated by protoc-gen-go.
// source: OSXNetworkConnect.proto
// DO NOT EDIT!

package msg

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type OSXNetworkConnect_ProtocolType int32

const (
	OSXNetworkConnect_IPVersion4 OSXNetworkConnect_ProtocolType = 0
	OSXNetworkConnect_IPVersion6 OSXNetworkConnect_ProtocolType = 1
)

var OSXNetworkConnect_ProtocolType_name = map[int32]string{
	0: "IPVersion4",
	1: "IPVersion6",
}
var OSXNetworkConnect_ProtocolType_value = map[string]int32{
	"IPVersion4": 0,
	"IPVersion6": 1,
}

func (x OSXNetworkConnect_ProtocolType) Enum() *OSXNetworkConnect_ProtocolType {
	p := new(OSXNetworkConnect_ProtocolType)
	*p = x
	return p
}
func (x OSXNetworkConnect_ProtocolType) String() string {
	return proto.EnumName(OSXNetworkConnect_ProtocolType_name, int32(x))
}
func (x *OSXNetworkConnect_ProtocolType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OSXNetworkConnect_ProtocolType_value, data, "OSXNetworkConnect_ProtocolType")
	if err != nil {
		return err
	}
	*x = OSXNetworkConnect_ProtocolType(value)
	return nil
}
func (OSXNetworkConnect_ProtocolType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor49, []int{0, 0}
}

type OSXNetworkConnect_StreamType int32

const (
	OSXNetworkConnect_TCP OSXNetworkConnect_StreamType = 0
	OSXNetworkConnect_UDP OSXNetworkConnect_StreamType = 1
)

var OSXNetworkConnect_StreamType_name = map[int32]string{
	0: "TCP",
	1: "UDP",
}
var OSXNetworkConnect_StreamType_value = map[string]int32{
	"TCP": 0,
	"UDP": 1,
}

func (x OSXNetworkConnect_StreamType) Enum() *OSXNetworkConnect_StreamType {
	p := new(OSXNetworkConnect_StreamType)
	*p = x
	return p
}
func (x OSXNetworkConnect_StreamType) String() string {
	return proto.EnumName(OSXNetworkConnect_StreamType_name, int32(x))
}
func (x *OSXNetworkConnect_StreamType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OSXNetworkConnect_StreamType_value, data, "OSXNetworkConnect_StreamType")
	if err != nil {
		return err
	}
	*x = OSXNetworkConnect_StreamType(value)
	return nil
}
func (OSXNetworkConnect_StreamType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor49, []int{0, 1}
}

// Notify server about the first connection after boot of an application to a certain remote IP address.
type OSXNetworkConnect struct {
	// The UTC time that the message was produced by the agent. Time is what was reported by the client clock.
	TimeStamp *int64 `protobuf:"varint,1,req,name=timeStamp" json:"timeStamp,omitempty"`
	// The unique identifier of the agent. This field is used by the server to distinguish agents.
	AgentGUID *string `protobuf:"bytes,2,req,name=agentGUID" json:"agentGUID,omitempty"`
	// Remote IP Address Protocol Type
	IPAddressProtocol *OSXNetworkConnect_ProtocolType `protobuf:"varint,3,req,name=IPAddressProtocol,enum=OSXNetworkConnect_ProtocolType" json:"IPAddressProtocol,omitempty"`
	// Remote IP Address (4 bytes for IPv4 and 16 bytes for IPv6 addresses)
	IPAddress []byte `protobuf:"bytes,4,req,name=IPAddress" json:"IPAddress,omitempty"`
	// The Process ID of the application
	PID *int32 `protobuf:"varint,5,req,name=PID" json:"PID,omitempty"`
	// The fully qualified filename of the binary: i.e. '/Applications/Skype.app/Contents/MacOS/Skype'
	ImageFilepath *string `protobuf:"bytes,6,req,name=imageFilepath" json:"imageFilepath,omitempty"`
	// The MD5 of the binary connecting to the remote IP (md5 of imageFilepath)
	ImageFileMD5 *string `protobuf:"bytes,7,opt,name=imageFileMD5" json:"imageFileMD5,omitempty"`
	// User (using this app) Information
	AccountName *string `protobuf:"bytes,8,opt,name=accountName" json:"accountName,omitempty"`
	DomainName  *string `protobuf:"bytes,9,opt,name=domainName" json:"domainName,omitempty"`
	// Port used to connect to the remote IP
	Port   *int32  `protobuf:"varint,10,opt,name=port" json:"port,omitempty"`
	SiteId *string `protobuf:"bytes,11,opt,name=siteId" json:"siteId,omitempty"`
	// Source IP Address (4 bytes for IPv4 and 16 bytes for IPv6 addresses)
	IPSourceAddress []byte `protobuf:"bytes,12,opt,name=IPSourceAddress" json:"IPSourceAddress,omitempty"`
	// Port used to connect to the source IP
	SourcePort           *int32                        `protobuf:"varint,13,opt,name=sourcePort" json:"sourcePort,omitempty"`
	ConnectionStreamType *OSXNetworkConnect_StreamType `protobuf:"varint,14,opt,name=connectionStreamType,enum=OSXNetworkConnect_StreamType" json:"connectionStreamType,omitempty"`
	ConnectionSuccessful *bool                         `protobuf:"varint,15,opt,name=connectionSuccessful" json:"connectionSuccessful,omitempty"`
	// Flag - true if incoming message, false if outgoing
	Incoming *bool `protobuf:"varint,16,opt,name=incoming" json:"incoming,omitempty"`
	// Version =1 so that IPaddress/port is 'destination' and IPSourceAddress/sourcePort is 'source'
	// Reversed from Windows to match industry standard
	Version          *int32  `protobuf:"varint,17,opt,name=version" json:"version,omitempty"`
	Uuid             *string `protobuf:"bytes,18,opt,name=uuid" json:"uuid,omitempty"`
	Hostname         *string `protobuf:"bytes,19,opt,name=hostname" json:"hostname,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OSXNetworkConnect) Reset()                    { *m = OSXNetworkConnect{} }
func (m *OSXNetworkConnect) String() string            { return proto.CompactTextString(m) }
func (*OSXNetworkConnect) ProtoMessage()               {}
func (*OSXNetworkConnect) Descriptor() ([]byte, []int) { return fileDescriptor49, []int{0} }

func (m *OSXNetworkConnect) GetTimeStamp() int64 {
	if m != nil && m.TimeStamp != nil {
		return *m.TimeStamp
	}
	return 0
}

func (m *OSXNetworkConnect) GetAgentGUID() string {
	if m != nil && m.AgentGUID != nil {
		return *m.AgentGUID
	}
	return ""
}

func (m *OSXNetworkConnect) GetIPAddressProtocol() OSXNetworkConnect_ProtocolType {
	if m != nil && m.IPAddressProtocol != nil {
		return *m.IPAddressProtocol
	}
	return OSXNetworkConnect_IPVersion4
}

func (m *OSXNetworkConnect) GetIPAddress() []byte {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

func (m *OSXNetworkConnect) GetPID() int32 {
	if m != nil && m.PID != nil {
		return *m.PID
	}
	return 0
}

func (m *OSXNetworkConnect) GetImageFilepath() string {
	if m != nil && m.ImageFilepath != nil {
		return *m.ImageFilepath
	}
	return ""
}

func (m *OSXNetworkConnect) GetImageFileMD5() string {
	if m != nil && m.ImageFileMD5 != nil {
		return *m.ImageFileMD5
	}
	return ""
}

func (m *OSXNetworkConnect) GetAccountName() string {
	if m != nil && m.AccountName != nil {
		return *m.AccountName
	}
	return ""
}

func (m *OSXNetworkConnect) GetDomainName() string {
	if m != nil && m.DomainName != nil {
		return *m.DomainName
	}
	return ""
}

func (m *OSXNetworkConnect) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *OSXNetworkConnect) GetSiteId() string {
	if m != nil && m.SiteId != nil {
		return *m.SiteId
	}
	return ""
}

func (m *OSXNetworkConnect) GetIPSourceAddress() []byte {
	if m != nil {
		return m.IPSourceAddress
	}
	return nil
}

func (m *OSXNetworkConnect) GetSourcePort() int32 {
	if m != nil && m.SourcePort != nil {
		return *m.SourcePort
	}
	return 0
}

func (m *OSXNetworkConnect) GetConnectionStreamType() OSXNetworkConnect_StreamType {
	if m != nil && m.ConnectionStreamType != nil {
		return *m.ConnectionStreamType
	}
	return OSXNetworkConnect_TCP
}

func (m *OSXNetworkConnect) GetConnectionSuccessful() bool {
	if m != nil && m.ConnectionSuccessful != nil {
		return *m.ConnectionSuccessful
	}
	return false
}

func (m *OSXNetworkConnect) GetIncoming() bool {
	if m != nil && m.Incoming != nil {
		return *m.Incoming
	}
	return false
}

func (m *OSXNetworkConnect) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *OSXNetworkConnect) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *OSXNetworkConnect) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func init() {
	proto.RegisterType((*OSXNetworkConnect)(nil), "OSXNetworkConnect")
	proto.RegisterEnum("OSXNetworkConnect_ProtocolType", OSXNetworkConnect_ProtocolType_name, OSXNetworkConnect_ProtocolType_value)
	proto.RegisterEnum("OSXNetworkConnect_StreamType", OSXNetworkConnect_StreamType_name, OSXNetworkConnect_StreamType_value)
}

var fileDescriptor49 = []byte{
	// 450 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x52, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x25, 0x4d, 0xd2, 0x24, 0x13, 0xc7, 0x71, 0xb6, 0x05, 0x56, 0x7c, 0x86, 0x9c, 0x38, 0xf9,
	0x50, 0x01, 0x07, 0x90, 0x90, 0x48, 0x23, 0x90, 0x0f, 0x2d, 0x2b, 0xb9, 0x45, 0x5c, 0xad, 0xf5,
	0x36, 0x5d, 0x11, 0xef, 0x5a, 0xbb, 0x6b, 0x10, 0x1c, 0xf9, 0x4f, 0xfc, 0x1a, 0xfe, 0x0c, 0xb3,
	0x6b, 0xb5, 0x24, 0x4a, 0x6f, 0xde, 0x37, 0x6f, 0xde, 0x7b, 0xe3, 0x19, 0x78, 0xf8, 0x39, 0xff,
	0x7a, 0x2e, 0xdc, 0x0f, 0x6d, 0xbe, 0x9d, 0x6a, 0xa5, 0x04, 0x77, 0x69, 0x6d, 0xb4, 0xd3, 0x8f,
	0x08, 0xd3, 0xd6, 0xad, 0x8d, 0xb0, 0x17, 0x3f, 0x6b, 0xd1, 0x62, 0x8b, 0xbf, 0x3d, 0x98, 0xed,
	0xf1, 0xc9, 0x1c, 0x46, 0x4e, 0x56, 0x22, 0x77, 0x45, 0x55, 0xd3, 0xce, 0xfc, 0xe0, 0x65, 0x77,
	0x39, 0xf9, 0xfd, 0x87, 0x06, 0xd0, 0x7a, 0x90, 0x3c, 0x86, 0x51, 0xb1, 0x16, 0xca, 0x7d, 0xba,
	0xcc, 0x56, 0xf4, 0x00, 0x19, 0xa3, 0xe5, 0x10, 0x19, 0xbd, 0xa6, 0x91, 0x25, 0x79, 0x0b, 0xb3,
	0x8c, 0x7d, 0x28, 0x4b, 0xb4, 0xb2, 0xcc, 0xdb, 0x70, 0xbd, 0xa1, 0x5d, 0x24, 0xc5, 0x27, 0xcf,
	0xd3, 0xfd, 0x74, 0x37, 0x14, 0x1f, 0xcb, 0x0b, 0xdf, 0xf6, 0xd2, 0x1e, 0xf6, 0x44, 0xad, 0xb0,
	0x54, 0xc2, 0x91, 0x31, 0x74, 0x19, 0xfa, 0xf5, 0x11, 0xee, 0x93, 0xfb, 0x30, 0x91, 0x15, 0x86,
	0xf8, 0x28, 0x37, 0xa2, 0x2e, 0xdc, 0x35, 0x3d, 0xf4, 0x31, 0xc8, 0x31, 0x44, 0xb7, 0xf0, 0xd9,
	0xea, 0x35, 0x1d, 0xcc, 0x3b, 0x88, 0x1e, 0xc1, 0xb8, 0xe0, 0x5c, 0x37, 0xca, 0x9d, 0x17, 0x95,
	0xa0, 0xc3, 0x00, 0x12, 0x80, 0x52, 0x57, 0x85, 0x54, 0x01, 0x1b, 0x05, 0x2c, 0x82, 0x5e, 0xad,
	0x8d, 0xa3, 0x80, 0xaf, 0x3e, 0x89, 0xe1, 0xd0, 0x4a, 0x27, 0xb2, 0x92, 0x8e, 0x43, 0xf5, 0x05,
	0x4c, 0x33, 0x96, 0xeb, 0xc6, 0x70, 0x71, 0x93, 0x31, 0xc2, 0xc2, 0x76, 0x46, 0x14, 0xb5, 0x81,
	0xc0, 0xbc, 0xcc, 0x24, 0xc8, 0xbc, 0x83, 0x63, 0xde, 0x0e, 0x2b, 0xb5, 0xca, 0x9d, 0x11, 0x45,
	0xe5, 0x87, 0xa5, 0x31, 0x56, 0xe3, 0x93, 0xa7, 0x77, 0xfc, 0x93, 0xff, 0x24, 0xf2, 0x64, 0xa7,
	0xb9, 0xe1, 0x1c, 0x5d, 0xaf, 0x9a, 0x0d, 0x9d, 0x62, 0xf3, 0x90, 0x24, 0x30, 0x94, 0x8a, 0xeb,
	0x4a, 0xaa, 0x35, 0x4d, 0x02, 0x32, 0x85, 0xc1, 0x77, 0x61, 0x2c, 0x92, 0xe9, 0x2c, 0xb8, 0x3f,
	0x80, 0xb0, 0x16, 0x4a, 0xfc, 0x08, 0x5b, 0x6b, 0xc2, 0xd6, 0x6b, 0xbc, 0x08, 0xe5, 0x87, 0x3f,
	0xf2, 0xb5, 0x45, 0x0a, 0xd1, 0xce, 0x32, 0x62, 0x80, 0x8c, 0x7d, 0x69, 0xc5, 0x5e, 0x25, 0xf7,
	0x76, 0xde, 0x6f, 0x92, 0xce, 0xe2, 0x19, 0xc0, 0x56, 0xd0, 0x01, 0x74, 0x2f, 0x4e, 0x19, 0xd2,
	0xf0, 0xe3, 0x72, 0xc5, 0x92, 0xce, 0xf2, 0x3d, 0x2c, 0x30, 0x5a, 0xfa, 0x4b, 0x5e, 0x39, 0xa1,
	0x52, 0x2b, 0x0c, 0x06, 0x6b, 0x0f, 0x0f, 0x1d, 0x52, 0xbc, 0x25, 0x8b, 0x8b, 0x5a, 0xd2, 0xbd,
	0xf1, 0xcf, 0xda, 0xca, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4e, 0xc3, 0xe9, 0x50, 0xcb, 0x02,
	0x00, 0x00,
}
